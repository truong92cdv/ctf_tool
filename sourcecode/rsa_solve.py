def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b%a,a)
    return (g, x - (b//a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('No modular inverse')
    return x%m




n = 661432982326720220312000264055749897099634058126069682916663983164095399891922239185277584515989571021804685855667350963576552884237075033389449261228025690631313796676189863627781905258968287175185368245091537181600636083142076805504788733126704459028930388517968658736636444935785049391422022025814770038260219959
e = 65537
c = 65730544585056113196855222491649915283458030302678764492256366948316495562844164405260875181381605385931592293174537287502809335112362051614031281550069787125630668940406746065617547709904187617743835592204030473969255847562554773875593313128402311178757607880009338508747805647372484237195480768305231875020498766
p = 25718339416197155016347059200722990565554067870853545610226371966653516052380672185338246396962573998431009659213305660299083786739031942533878562393814187971
q = 25718339416197155016347059200722990565554067870853545610226371966653516052382546957914320289812433453859436193345068829987610976923180252683267226804850952829

# phi = (p-1)*(q-1)
# d = modinv(e, phi)


m = hex(pow(c, d, n))[2:-1]
flag = m.decode("hex")

print '\nFlag = %s\n' % flag